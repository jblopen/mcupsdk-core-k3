%%{
    let common = system.getScript("/common");
    let flash_module = system.modules['/board/flash/flash'];
    let filex_module = system.modules['/fs/filex/filex'];
    let filex_instances = filex_module.$instances;
    let ramdisk_instances = _.filter(filex_instances, function (inst) { return (inst.media == "RAMDISK");})
    let flash_instances = _.filter(filex_instances, function (inst) { return (inst.media == "SERIAL_FLASH");})

    let nor_instances = _.filter(flash_instances, function (inst) { return (!inst.peripheralDriver.serialFlashDriver.hasOwnProperty('flashType') || 
                                                                             inst.peripheralDriver.serialFlashDriver.flashType == "SERIAL_NOR"); })
    let nand_instances = _.filter(flash_instances, function (inst) { return (inst.peripheralDriver.serialFlashDriver.hasOwnProperty('flashType') &&
                                                                             inst.peripheralDriver.serialFlashDriver.flashType == "SERIAL_NAND"); })
    let mmcsd_instances = _.filter(filex_module.$instances, function (inst) { return ((inst.media == "EMMC") || (inst.media == "SD"));})
%%}

/*
 * FileX
 */

#include <tx_port.h>
% if (nor_instances.length > 0) {
#include <filex_levelx_nor_driver.h>
#include <lx_nor_flash_driver.h>
#include <lx_api.h>
% }
% if (nand_instances.length > 0) {
#include <filex_levelx_nand_driver.h>
#include <lx_nand_flash_driver.h>
#include <lx_api.h>
% }
% if (mmcsd_instances.length > 0) {
#include <filex_mmcsd.h>
% }

% if (ramdisk_instances.length > 0) {
extern void _fx_ram_driver(FX_MEDIA *);
% }

FX_MEDIA gMedia[FILEX_NUM_INSTANCES];
% if (nor_instances.length > 0) {
static LX_NOR_FLASH gNor[FILEX_NOR_NUM_INSTANCES];
% }
% if (nand_instances.length > 0) {
static LX_NAND_FLASH gNand[FILEX_NAND_NUM_INSTANCES];
% }
static unsigned char gMediaMem[FILEX_NUM_INSTANCES][16u * 1024];
% for (let k = 0; k < ramdisk_instances.length; k++) {
static unsigned gRamDisk`k`_mem[`ramdisk_instances[k].ramdisk_size`];
% }


% if (nand_instances.length > 0) {
#define GET_MAX(a, b)    ((a) > (b) ? (a) : (b))
#define MEM_SIZE_GET(block_count, page_size, spare_size) \
           (GET_MAX(page_size, block_count * sizeof(USHORT)) + \
            GET_MAX(page_size, block_count * sizeof(UCHAR)) + \
            block_count * sizeof(USHORT) + \
            GET_MAX(page_size, block_count * sizeof(USHORT)) + \
            2 * (page_size + spare_size))

    % for (let k = 0; k < nand_instances.length; k++) {
    %   let serial_flash_driver = nand_instances[k].peripheralDriver.serialFlashDriver;
static UCHAR g`serial_flash_driver.fname`Mem[MEM_SIZE_GET(`serial_flash_driver.flashSize / serial_flash_driver.flashBlockSize`, `serial_flash_driver.flashPageSize`, `serial_flash_driver.flashSpareAreaSize`)]__attribute__((aligned(128)));
    % }
% }


int32_t EclipseThreadx_FilexOpen(void)
{
    UINT status;

    /* Initialize FileX. */
    fx_system_initialize();

% if (nor_instances.length > 0) {
    /* Initialize LevelX-NOR. */
    lx_nor_flash_initialize();
%} 

% if (nand_instances.length > 0) {
    /* Initialize LevelX-NAND. */
    lx_nand_flash_initialize();
%} 

% let filex_ctr = 0;
% let ramdisk_ctr = 0;
% let nor_ctr = 0;
% let nand_ctr = 0;
% for (let k = 0; k < filex_instances.length; k++) {
    % let filex_inst = filex_instances[k];
    /*************** `filex_inst.$name` Init *********************/
    {
        % let driver;
        % let driver_data;
        % let sec_cnt;
        % if (filex_inst.media == "RAMDISK") {
            % driver = '_fx_ram_driver';
            % driver_data = '(void *)&gRamDisk' + ramdisk_ctr + '_mem[0]';
            % sec_cnt = filex_inst.ramdisk_size / filex_inst.sector_size;
            % ramdisk_ctr++;
        % } else if ((filex_inst.media == "SD" || filex_inst.media == "EMMC")) {
            % driver = '_fx_mmcsd_driver';
            % driver_data = '(void *)' + filex_inst.peripheralDriver.$name;
            % sec_cnt = 'sec_cnt';
        
            uint32_t sec_cnt;
            MMCSD_Handle mmcsd_hndl;
            
            mmcsd_hndl = MMCSD_getHandle(`filex_inst.peripheralDriver.$name`);
            if (mmcsd_hndl == NULL) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: " "`filex_inst.peripheralDriver.$name`" " not found !!!\r\n");
                return (SystemP_FAILURE);
            }
    
            sec_cnt = MMCSD_getBlockCount(mmcsd_hndl) * MMCSD_getBlockSize(mmcsd_hndl) / `filex_inst.sector_size`U;
    
        % } else if (filex_inst.media == "SERIAL_FLASH") {
            % let serial_driver_inst = filex_inst.peripheralDriver.serialFlashDriver;
            % let flash_type = (!serial_driver_inst.hasOwnProperty('flashType') || (serial_driver_inst.flashType == 'SERIAL_NOR')) ? 'SERIAL_NOR' : 
            %                  (serial_driver_inst.hasOwnProperty('flashType') && (serial_driver_inst.flashType == 'SERIAL_NAND')) ? 'SERIAL_NAND' : 'UNKNOWN';
            % if (flash_type == 'SERIAL_NOR') {
            %    driver = '_fx_nor_driver';
            %    driver_data = '(void *)&gNor[' + nor_ctr + ']';
            % } else if (flash_type == 'SERIAL_NAND') {
            %    driver = '_fx_nand_driver';
            %    driver_data = '(void *)&gNand[' + nand_ctr + ']';
            % }
            % sec_cnt = 'sec_cnt';
        uint32_t sec_cnt;
        uint64_t flash_size;

            % if (flash_type == 'SERIAL_NOR') {
        /* Create a LevelX NOR driver instance and attach it to a flash configuration. */
        status = lx_nor_driver_create(&gNor[`nor_ctr`], `filex_inst.peripheralDriver.$name`, `filex_inst.fs_offset`, `filex_inst.fs_size`);
        if (status != LX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nor_driver_create() returned error %d !!!\r\n", status);
            return (SystemP_FAILURE);
        }

        /* Open a LevelX NOR instance. */
        status = lx_nor_flash_open(&gNor[`nor_ctr`], "`filex_inst.peripheralDriver.$name`", lx_nor_driver_init);
        if (status != LX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nor_driver_create() returned error %d !!!\r\n", status);
            return (SystemP_FAILURE);
        }

        /* Query the flash size (taking into account the offset and size parameters). */
        flash_size = lx_nor_driver_size_get(&gNor[`nor_ctr`]);
        sec_cnt = flash_size / `filex_inst.sector_size`U;

            % nor_ctr++;
            % } else {
        const UINT spare_map[][2] = `serial_driver_inst.flashSpareAreaMap`; 

        /* Create a LevelX NAND driver instance and attach it to a flash configuration. */
        status = lx_nand_driver_create(&gNand[`nand_ctr`], `filex_inst.peripheralDriver.$name`, `filex_inst.fs_offset`, `filex_inst.fs_size`, spare_map, sizeof(spare_map) / sizeof(spare_map[0]));
        if (status != LX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nand_driver_create() returned error %d !!!\r\n", status);
            return (SystemP_FAILURE);
        }

        /* Open a LevelX NAND instance. */
        status = lx_nand_flash_open(&gNand[`nand_ctr`], "`filex_inst.peripheralDriver.$name`", lx_nand_driver_init, (ULONG *)&g`serial_driver_inst.fname`Mem[0], sizeof(g`serial_driver_inst.fname`Mem));
        if (status != LX_SUCCESS) {
        % if (filex_inst.auto_format) {
            status = lx_nand_flash_format(&gNand[`nand_ctr`], "`filex_inst.peripheralDriver.$name`", lx_nand_driver_init, (ULONG *)&g`serial_driver_inst.fname`Mem[0], sizeof(g`serial_driver_inst.fname`Mem));
            if (status != LX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nand_flash_format() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            }
            /* Open a LevelX NAND instance. */
            status = lx_nand_flash_open(&gNand[`nand_ctr`], "`filex_inst.peripheralDriver.$name`", lx_nand_driver_init, (ULONG *)&g`serial_driver_inst.fname`Mem[0], sizeof(g`serial_driver_inst.fname`Mem));
            if (status != LX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nand_flash_open() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            }
        % } else {
            if (status != LX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: lx_nand_flash_open() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            } 
        % }
        }

        /* Query the flash size (taking into account the offset and size parameters). */
        flash_size = lx_nand_driver_size_get(&gNand[`nand_ctr`]);
        sec_cnt = flash_size / `filex_inst.sector_size`U;

            % nand_ctr++;
            % }
        % }

        /* Try to open the media. If the media is not formatted, format and try again. */
        memset(&gMedia[`filex_ctr`], 0, sizeof(FX_MEDIA));
        status = fx_media_open(&gMedia[`filex_ctr`], "`filex_inst.$name`", `driver`, `driver_data`, gMediaMem[`filex_ctr`], sizeof(gMediaMem[`filex_ctr`]));
        if (status != FX_SUCCESS) {
        % if (filex_inst.auto_format) {

            /* Format the media. */
            status = fx_media_format(&gMedia[`filex_ctr`], `driver`, `driver_data`, gMediaMem[`filex_ctr`], sizeof(gMediaMem[`filex_ctr`]), 
                                 "`filex_inst.$name`", `filex_inst.fat_cnt`, `filex_inst.dir_entry_cnt`, `filex_inst.hidden_sec_cnt`, `sec_cnt`, `filex_inst.sector_size`U, `filex_inst.sectors_per_cluster`, 1, 1);
            if (status != FX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_format() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            }
            /* Open the media. */
            status =  fx_media_open(&gMedia[`filex_ctr`], "`filex_inst.$name`", `driver`, `driver_data`, gMediaMem[`filex_ctr`], sizeof(gMediaMem[`filex_ctr`]));
            if (status != FX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            }
        % } else {
            if (status != FX_SUCCESS) {
                DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
                return (SystemP_FAILURE);
            } 
        % }
        }
    }
    % filex_ctr++;
%}

    return (SystemP_SUCCESS);
}

void EclipseThreadx_FilexClose(void)
{
    /* Nothing to do. */
}